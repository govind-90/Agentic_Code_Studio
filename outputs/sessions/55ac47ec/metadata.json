{
  "session_id": "55ac47ec",
  "requirements": "Implement the 0/1 knapsack problem using dynamic programming. Include clear function and example usage.",
  "language": "python",
  "created_at": "2025-12-05T12:39:33.054285",
  "updated_at": "2025-12-05T12:41:58.417435",
  "status": "success",
  "current_iteration": 5,
  "max_iterations": 5,
  "iterations": [
    {
      "iteration_number": 1,
      "timestamp": "2025-12-05T12:39:33.055341",
      "code_gen_status": "success",
      "build_status": "success",
      "test_status": "failed",
      "generated_code": "",
      "build_result": {
        "status": "success",
        "dependencies": [],
        "build_instructions": "Code is ready for execution",
        "errors": [],
        "suggested_fixes": []
      },
      "test_result": {
        "status": "fail",
        "test_cases": [
          {
            "name": "Basic Execution",
            "status": "fail",
            "description": "Code execution test",
            "error": null
          }
        ],
        "execution_logs": "\n",
        "performance": null,
        "issues_found": [
          "No output generated"
        ],
        "recommendations": [
          "Verify code logic and expected output"
        ]
      },
      "error_type": "logic",
      "error_message": "No output generated",
      "error_context": null
    },
    {
      "iteration_number": 2,
      "timestamp": "2025-12-05T12:40:09.400814",
      "code_gen_status": "success",
      "build_status": "failed",
      "test_status": "pending",
      "generated_code": "# FILE: knapsack_solver.py\n\nimport logging\nfrom typing import List, Tuple\n\n# Setup basic logging configuration\nlogging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\nlogger = logging.getLogger(__name__)\n\ndef knapsack_dp(capacity: int, weights: List[int], values: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Solves the 0/1 Knapsack problem using dynamic programming.\n\n    The function calculates the maximum value that can be achieved by selecting \n    a subset of items such that their total weight does not exceed the knapsack capacity.\n\n    Args:\n        capacity: The maximum weight the knapsack can hold.\n        weights: A list of weights for each item.\n        values: A list of values for each item (must correspond to weights).\n\n    Returns:\n        A tuple containing:\n        1. The maximum total value achievable.\n        2. A list of indices of the items selected.\n    \"\"\"\n    N = len(weights)\n    if N != len(values):\n        raise ValueError(\"Weights and values lists must have the same length.\")\n    \n    if capacity < 0:\n        raise ValueError(\"Capacity must be non-negative.\")\n\n    # 1. Initialize the DP table\n    # dp[i][w] stores the maximum value achievable using the first 'i' items\n    # with a maximum weight capacity of 'w'.\n    # Dimensions: (N + 1) rows, (capacity + 1) columns\n    dp = [[0] * (capacity + 1) for _ in range(N + 1)]\n\n    logger.debug(f\"Starting DP calculation for {N} items and capacity {capacity}\")\n\n    # 2. Fill the DP table\n    for i in range(1, N + 1):\n        # Current item index (0-based) is i - 1\n        item_index = i - 1\n        w_i = weights[item_index]\n        v_i = values[item_index]\n\n        for w in range(capacity + 1):\n            \n            # If the current item's weight exceeds the current capacity 'w', \n            # we cannot include it. Value is inherited from the previous row.\n            if w_i > w:\n                dp[i][w] = dp[i - 1][w]\n            \n            # Otherwise, we choose the maximum between:\n            # a) Excluding the item (dp[i - 1][w])\n            # b) Including the item (v_i + dp[i - 1][w - w_i])\n            else:\n                value_if_excluded = dp[i - 1][w]\n                value_if_included = v_i + dp[i - 1][w - w_i]\n                \n                dp[i][w] = max(value_if_excluded, value_if_included)\n                \n    max_value = dp[N][capacity]\n\n    # 3. Reconstruct the selected items\n    selected_items: List[int] = []\n    w = capacity\n    \n    # Iterate backwards through the DP table rows (items)\n    for i in range(N, 0, -1):\n        # If dp[i][w] is greater than dp[i-1][w], it means item i-1 was included\n        # to achieve the maximum value at this capacity 'w'.\n        if dp[i][w] != dp[i - 1][w]:\n            item_index = i - 1\n            selected_items.append(item_index)\n            \n            # Reduce the remaining capacity by the weight of the selected item\n            w -= weights[item_index]\n            \n            if w == 0:\n                break\n    \n    # Reverse the list to get items in ascending index order\n    selected_items.reverse()\n    \n    return max_value, selected_items\n\nif __name__ == \"__main__\":\n    # Set logging level to INFO for standard execution output\n    logging.getLogger().setLevel(logging.INFO)\n    \n    print(\"--- 0/1 Knapsack Problem Solver (Dynamic Programming) ---\")\n\n    # Sample Data Definition\n    # Item 0: (W=2, V=3)\n    # Item 1: (W=3, V=4)\n    # Item 2: (W=4, V=5)\n    # Item 3: (W=5, V=8)\n    # Item 4: (W=9, V=10)\n    \n    weights = [2, 3, 4, 5, 9]\n    values = [3, 4, 5, 8, 10]\n    capacity_1 = 10\n    \n    print(f\"\\nAvailable Items (Index, Weight, Value):\")\n    for i, (w, v) in enumerate(zip(weights, values)):\n        print(f\"  Item {i}: Weight={w}, Value={v}\")\n        \n    print(f\"\\n--- Test Case 1: Capacity {capacity_1} ---\")\n\n    try:\n        # Expected optimal solution for capacity 10: Items 1, 2, 3 (3+4+5 = 12 > 10, impossible)\n        # Optimal: Items 0, 2, 3 (2+4+5 = 11 > 10, impossible)\n        # Optimal: Items 0, 1, 3 (2+3+5 = 10, V=3+4+8 = 15) -> This is the maximum.\n        \n        max_value, selected_indices = knapsack_dp(capacity_1, weights, values)\n        \n        selected_items_details = []\n        total_weight = 0\n        \n        for index in selected_indices:\n            w = weights[index]\n            v = values[index]\n            selected_items_details.append(f\"Item {index} (W={w}, V={v})\")\n            total_weight += w\n            \n        print(f\"Maximum Value Achievable: {max_value}\")\n        print(f\"Total Weight Used: {total_weight}\")\n        print(f\"Selected Items ({len(selected_indices)}):\")\n        \n        if selected_items_details:\n            for detail in selected_items_details:\n                print(f\"  - {detail}\")\n        else:\n            print(\"  - None\")\n\n        # Test Case 2: Smaller capacity\n        capacity_2 = 7\n        print(f\"\\n--- Test Case 2: Capacity {capacity_2} ---\")\n        \n        # Expected optimal solution for capacity 7: Items 0, 3 (2+5 = 7, V=3+8 = 11)\n        max_value_2, selected_indices_2 = knapsack_dp(capacity_2, weights, values)\n        \n        selected_items_details_2 = []\n        total_weight_2 = 0\n        for index in selected_indices_2:\n            w = weights[index]\n            v = values[index]\n            selected_items_details_2.append(f\"Item {index} (W={w}, V={v})\")\n            total_weight_2 += w\n\n        print(f\"Maximum Value Achievable: {max_value_2}\")\n        print(f\"Total Weight Used: {total_weight_2}\")\n        print(f\"Selected Items ({len(selected_indices_2)}):\")\n        for detail in selected_items_details_2:\n            print(f\"  - {detail}\")\n\n\n    except ValueError as e:\n        logger.error(f\"Input Error: {e}\")\n    except Exception as e:\n        logger.critical(f\"An unexpected error occurred: {e}\")\n        \n    print(\"\\n--- Execution Complete ---\")\n<ctrl63>",
      "build_result": {
        "status": "error",
        "dependencies": [
          "logging",
          "typing"
        ],
        "build_instructions": "Fix syntax errors before proceeding",
        "errors": [
          "Syntax error at line 167: invalid syntax"
        ],
        "suggested_fixes": [
          "Fix syntax error: invalid syntax"
        ]
      },
      "test_result": null,
      "error_type": "logic",
      "error_message": "Syntax error at line 167: invalid syntax",
      "error_context": null
    },
    {
      "iteration_number": 3,
      "timestamp": "2025-12-05T12:40:26.174534",
      "code_gen_status": "success",
      "build_status": "failed",
      "test_status": "pending",
      "generated_code": "# REQUIRES: None\n\nimport logging\nfrom typing import List, Tuple\n\n# Configure basic logging\nlogging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\n\ndef knapsack_01_dp(\n    values: List[int], \n    weights: List[int], \n    capacity: int\n) -> Tuple[int, List[int]]:\n    \"\"\"\n    Solves the 0/1 Knapsack problem using dynamic programming.\n\n    The 0/1 Knapsack problem seeks to maximize the total value of items \n    included in a knapsack without exceeding its weight capacity, where \n    each item can only be included once (0 or 1 time).\n\n    Args:\n        values: List of values for each item.\n        weights: List of weights for each item.\n        capacity: The maximum weight capacity of the knapsack.\n\n    Returns:\n        A tuple containing:\n        1. The maximum total value achievable.\n        2. A list of indices (0-based) of the items included.\n    \"\"\"\n    n = len(values)\n    \n    if n == 0 or capacity <= 0:\n        return 0, []\n\n    # Initialize the DP table: dp[i][w] stores the maximum value achievable \n    # using the first 'i' items with a maximum weight capacity of 'w'.\n    # Dimensions: (n + 1) rows, (capacity + 1) columns.\n    # We use n+1 and capacity+1 to handle 0-based indexing easily (i=0 or w=0 means no items/capacity).\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    logging.debug(f\"Starting DP calculation for {n} items and capacity {capacity}\")\n\n    # Fill the DP table\n    for i in range(1, n + 1):\n        # Current item index in original lists is i - 1\n        current_weight = weights[i - 1]\n        current_value = values[i - 1]\n\n        for w in range(capacity + 1):\n            if current_weight > w:\n                # Case 1: Item i is too heavy to include.\n                # The max value is the same as the max value without item i.\n                dp[i][w] = dp[i - 1][w]\n            else:\n                # Case 2: Item i can be included. We choose the maximum of two options:\n                \n                # Option A: Exclude item i (Value = dp[i-1][w])\n                value_excluding = dp[i - 1][w]\n                \n                # Option B: Include item i (Value = current_value + dp[i-1][w - current_weight])\n                value_including = current_value + dp[i - 1][w - current_weight]\n                \n                dp[i][w] = max(value_excluding, value_including)\n                \n    max_value = dp[n][capacity]\n    \n    # --- Traceback: Determine which items were included ---\n    \n    w = capacity\n    included_items_indices = []\n    \n    # Iterate backwards from the last item (n)\n    for i in range(n, 0, -1):\n        # If the value at dp[i][w] is greater than dp[i-1][w], \n        # it means item i (index i-1) must have been included to achieve this value.\n        if dp[i][w] != dp[i - 1][w]:\n            \n            # Item i (index i-1) was included\n            item_index = i - 1\n            included_items_indices.append(item_index)\n            \n            # Subtract the weight of the included item from the remaining capacity\n            w -= weights[item_index]\n            \n            # Safety check: if capacity drops below zero, something is wrong, but DP ensures w >= 0\n            if w < 0:\n                break \n    \n    # The items are found in reverse order of processing; reverse them for natural order\n    included_items_indices.reverse()\n    \n    return max_value, included_items_indices\n\nif __name__ == \"__main__\":\n    \n    # Example 1: Standard Knapsack Problem\n    \n    # Item 0: (10, 2), Item 1: (4, 3), Item 2: (7, 4), Item 3: (5, 5)\n    example_items = [\n        {\"name\": \"A\", \"value\": 10, \"weight\": 2},\n        {\"name\": \"B\", \"value\": 4, \"weight\": 3},\n        {\"name\": \"C\", \"value\": 7, \"weight\": 4},\n        {\"name\": \"D\", \"value\": 5, \"weight\": 5},\n    ]\n    \n    CAPACITY_1 = 8\n    \n    values_1 = [item['value'] for item in example_items]\n    weights_1 = [item['weight'] for item in example_items]\n    \n    print(\"--- Example 1: Capacity 8 ---\")\n    print(f\"Items: {example_items}\")\n    print(f\"Capacity: {CAPACITY_1}\")\n    \n    try:\n        max_value_1, included_indices_1 = knapsack_01_dp(values_1, weights_1, CAPACITY_1)\n        \n        included_items_1 = [example_items[i] for i in included_indices_1]\n        total_weight_1 = sum(item['weight'] for item in included_items_1)\n        \n        print(f\"\\nMaximum Value Achieved: {max_value_1}\")\n        print(f\"Total Weight Used: {total_weight_1}\")\n        print(\"Included Items:\")\n        for item in included_items_1:\n            print(f\"  - {item['name']} (Value: {item['value']}, Weight: {item['weight']})\")\n            \n    except Exception as e:\n        logging.error(f\"An error occurred during Example 1 execution: {e}\")\n\n    print(\"\\n\" + \"=\"*40 + \"\\n\")\n\n    # Example 2: Different Capacity and Items\n    \n    example_items_2 = [\n        {\"name\": \"X\", \"value\": 60, \"weight\": 10},\n        {\"name\": \"Y\", \"value\": 100, \"weight\": 20},\n        {\"name\": \"Z\", \"value\": 120, \"weight\": 30},\n    ]\n    \n    CAPACITY_2 = 50\n    \n    values_2 = [item['value'] for item in example_items_2]\n    weights_2 = [item['weight'] for item in example_items_2]\n    \n    print(\"--- Example 2: Capacity 50 ---\")\n    print(f\"Items: {example_items_2}\")\n    print(f\"Capacity: {CAPACITY_2}\")\n    \n    try:\n        max_value_2, included_indices_2 = knapsack_01_dp(values_2, weights_2, CAPACITY_2)\n        \n        included_items_2 = [example_items_2[i] for i in included_indices_2]\n        total_weight_2 = sum(item['weight'] for item in included_items_2)\n        \n        print(f\"\\nMaximum Value Achieved: {max_value_2}\") # Expected: 220 (Y + Z)\n        print(f\"Total Weight Used: {total_weight_2}\") # Expected: 50\n        print(\"Included Items:\")\n        for item in included_items_2:\n            print(f\"  - {item['name']} (Value: {item['value']}, Weight: {item['weight']})\")\n            \n    except Exception as e:\n        logging.error(f\"An error occurred during Example 2 execution: {e}\")\n        \n    print(\"\\n\" + \"=\"*40 + \"\\n\")\n\n    # Example 3: Edge Case (Capacity too small)\n    \n    CAPACITY_3 = 5\n    \n    print(\"--- Example 3: Capacity 5 (Edge Case) ---\")\n    print(f\"Items: {example_items_2}\")\n    print(f\"Capacity: {CAPACITY_3}\")\n    \n    try:\n        max_value_3, included_indices_3 = knapsack_01_dp(values_2, weights_2, CAPACITY_3)\n        \n        included_items_3 = [example_items_2[i] for i in included_indices_3]\n        total_weight_3 = sum(item['weight'] for item in included_items_3)\n        \n        print(f\"\\nMaximum Value Achieved: {max_value_3}\") # Expected: 0\n        print(f\"Total Weight Used: {total_weight_3}\") # Expected: 0\n        print(f\"Included Items: {included_items_3}\")\n            \n    except Exception as e:\n        logging.error(f\"An error occurred during Example 3 execution: {e}\")\n<ctrl63>",
      "build_result": {
        "status": "error",
        "dependencies": [
          "logging",
          "typing",
          "None"
        ],
        "build_instructions": "Fix syntax errors before proceeding",
        "errors": [
          "Syntax error at line 187: invalid syntax"
        ],
        "suggested_fixes": [
          "Fix syntax error: invalid syntax"
        ]
      },
      "test_result": null,
      "error_type": "logic",
      "error_message": "Syntax error at line 187: invalid syntax",
      "error_context": null
    },
    {
      "iteration_number": 4,
      "timestamp": "2025-12-05T12:40:43.135304",
      "code_gen_status": "success",
      "build_status": "failed",
      "test_status": "pending",
      "generated_code": "# REQUIRES: typing, logging\n\nimport logging\nfrom typing import List, Tuple, Dict, Any\n\n# Setup basic logging configuration\n# Set level to INFO for standard execution output. Change to DEBUG to see DP trace.\nlogging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\nlogger = logging.getLogger(__name__)\n\ndef knapsack_dp(\n    capacity: int,\n    weights: List[int],\n    values: List[int]\n) -> Tuple[int, List[List[int]]]:\n    \"\"\"\n    Solves the 0/1 Knapsack problem using dynamic programming.\n\n    The DP table DP[i][w] stores the maximum value achievable using the first\n    i items with a capacity limit of w.\n\n    Args:\n        capacity: The maximum weight the knapsack can hold (W).\n        weights: List of weights for each item (w_1, w_2, ...).\n        values: List of values for each item (v_1, v_2, ...).\n\n    Returns:\n        A tuple containing:\n        1. The maximum total value achievable.\n        2. The DP table used for calculation (useful for reconstruction).\n    \"\"\"\n    N = len(weights)\n    W = capacity\n\n    if N == 0 or W <= 0:\n        return 0, []\n\n    # Initialize the DP table (N+1 rows for items, W+1 columns for capacity)\n    # dp_table[i][w]\n    # Row 0 and Column 0 are base cases (0 value, 0 capacity)\n    dp_table = [[0] * (W + 1) for _ in range(N + 1)]\n\n    logger.debug(f\"Starting DP calculation for {N} items and capacity {W}\")\n\n    # Iterate through items (i = 1 to N)\n    for i in range(1, N + 1):\n        # Get the weight and value of the current item (i-1 in 0-based lists)\n        item_weight = weights[i - 1]\n        item_value = values[i - 1]\n\n        # Iterate through capacities (w = 1 to W)\n        for w in range(1, W + 1):\n            \n            # Case 1: If the current item's weight exceeds the current capacity 'w',\n            # we cannot include it. The max value is the same as without this item.\n            if item_weight > w:\n                dp_table[i][w] = dp_table[i - 1][w]\n                logger.debug(f\"i={i}, w={w}: Excluded (Weight {item_weight} > {w}). Value: {dp_table[i][w]}\")\n            \n            # Case 2: We can potentially include the item.\n            else:\n                # Option A: Exclude the current item (Value = DP[i-1][w])\n                value_excluding = dp_table[i - 1][w]\n                \n                # Option B: Include the current item \n                # Value = item_value + DP[i-1][w - item_weight]\n                value_including = item_value + dp_table[i - 1][w - item_weight]\n                \n                # Choose the maximum of the two options\n                dp_table[i][w] = max(value_excluding, value_including)\n                logger.debug(f\"i={i}, w={w}: Max Value: {dp_table[i][w]}\")\n\n    # The maximum value is stored at the bottom-right corner\n    max_value = dp_table[N][W]\n    \n    return max_value, dp_table\n\ndef reconstruct_items(\n    capacity: int,\n    weights: List[int],\n    values: List[int],\n    dp_table: List[List[int]]\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Traces back the DP table to determine which items were selected.\n    \"\"\"\n    N = len(weights)\n    W = capacity\n    selected_items = []\n\n    if not dp_table:\n        return []\n\n    # Start tracing from the bottom-right corner\n    current_w = W\n    \n    # Iterate backwards through items (from N down to 1)\n    for i in range(N, 0, -1):\n        \n        # If the value at DP[i][current_w] is greater than DP[i-1][current_w], \n        # it means item 'i' (index i-1) must have been included.\n        # Note: We use != because sometimes the value might be the same even if included \n        # (e.g., if the item value is 0), but standard 0/1 knapsack assumes positive values.\n        # The robust check is: if the current max value is NOT equal to the max value \n        # achievable without this item, then this item was chosen.\n        \n        if dp_table[i][current_w] != dp_table[i - 1][current_w]:\n            # Item i was included\n            item_index = i - 1\n            item_weight = weights[item_index]\n            item_value = values[item_index]\n            \n            selected_items.append({\n                \"index\": item_index,\n                \"weight\": item_weight,\n                \"value\": item_value\n            })\n            \n            # Update the remaining capacity by subtracting the weight of the selected item\n            current_w -= item_weight\n            logger.debug(f\"Item {item_index} selected. Remaining capacity: {current_w}\")\n            \n        else:\n            # Item i was excluded\n            logger.debug(f\"Item {i-1} excluded.\")\n\n    # Reverse the list so items are listed in their original index order\n    return selected_items[::-1]\n\ndef solve_knapsack(capacity: int, weights: List[int], values: List[int]):\n    \"\"\"\n    Main function to solve and display the knapsack results.\n    \"\"\"\n    N = len(weights)\n    if N != len(values):\n        logger.error(\"Weights and values lists must have the same length.\")\n        return\n\n    print(f\"\\n--- Solving 0/1 Knapsack Problem ---\")\n    print(f\"Capacity (W): {capacity}\")\n    print(f\"Items (Index, Weight, Value):\")\n    for i in range(N):\n        print(f\"  ({i}, {weights[i]}, {values[i]})\")\n\n    try:\n        max_value, dp_table = knapsack_dp(capacity, weights, values)\n        \n        if capacity <= 0:\n            logger.warning(\"Capacity is zero or negative. Max value is 0.\")\n            max_value = 0\n            selected_items = []\n        else:\n            selected_items = reconstruct_items(capacity, weights, values, dp_table)\n\n        total_weight = sum(item['weight'] for item in selected_items)\n        \n        print(\"\\n--- Results ---\")\n        print(f\"Maximum Total Value: {max_value}\")\n        print(f\"Total Weight Used: {total_weight}\")\n        print(f\"Remaining Capacity: {capacity - total_weight}\")\n        print(\"\\nSelected Items:\")\n        \n        if not selected_items:\n            print(\"No items selected.\")\n        else:\n            for item in selected_items:\n                print(f\"  Item Index {item['index']}: Weight={item['weight']}, Value={item['value']}\")\n\n    except Exception as e:\n        logger.critical(f\"An unexpected error occurred during knapsack solving: {e}\")\n\n\nif __name__ == \"__main__\":\n    # Example 1: Standard Knapsack Problem\n    W1 = 50\n    weights1 = [10, 20, 30]\n    values1 = [60, 100, 120]\n    # Expected: Items 0 (10, 60) and 1 (20, 100). Total: W=30, V=160.\n    \n    solve_knapsack(W1, weights1, values1)\n\n    print(\"\\n\" + \"=\"*70 + \"\\n\")\n\n    # Example 2: More complex scenario\n    W2 = 15\n    weights2 = [4, 6, 8, 3, 5]\n    values2 = [7, 6, 9, 4, 5]\n    # Expected: Items 0(4, 7), 1(6, 6), 3(3, 4). Total: W=13, V=17.\n    \n    solve_knapsack(W2, weights2, values2)\n    \n    print(\"\\n\" + \"=\"*70 + \"\\n\")\n\n    # Example 3: Edge case - Capacity too small\n    W3 = 2\n    weights3 = [10, 5, 1]\n    values3 = [100, 50, 5]\n    # Expected: Item 2 (1, 5). Total: W=1, V=5.\n    solve_knapsack(W3, weights3, values3)\n    \n    print(\"\\n\" + \"=\"*70 + \"\\n\")\n    \n    # Example 4: Empty input\n    W4 = 10\n    weights4 = []\n    values4 = []\n    solve_knapsack(W4, weights4, values4)\n    \n    print(\"\\n\" + \"=\"*70 + \"\\n\")\n    \n    # Example 5: Zero capacity\n    W5 = 0\n    weights5 = [1, 1]\n    values5 = [10, 10]\n    solve_knapsack(W5, weights5, values5)\n    \n    # Note: To enable detailed DP tracing, change logger.setLevel(logging.DEBUG) \n    # at the start of the __main__ block.\n    # logger.setLevel(logging.DEBUG) \n    # solve_knapsack(W1, weights1, values1)\n    # logger.setLevel(logging.INFO)\n    \n    pass\n```",
      "build_result": {
        "status": "error",
        "dependencies": [
          "logging",
          "typing"
        ],
        "build_instructions": "Fix syntax errors before proceeding",
        "errors": [
          "Syntax error at line 224: invalid syntax"
        ],
        "suggested_fixes": [
          "Fix syntax error: invalid syntax"
        ]
      },
      "test_result": null,
      "error_type": "logic",
      "error_message": "Syntax error at line 224: invalid syntax",
      "error_context": null
    },
    {
      "iteration_number": 5,
      "timestamp": "2025-12-05T12:41:07.966333",
      "code_gen_status": "success",
      "build_status": "success",
      "test_status": "success",
      "generated_code": "# REQUIRES: None (Standard Python 3.10+)\n\nimport logging\nfrom typing import List, Tuple\n\n# Setup basic logging. Set level to INFO for standard output, DEBUG for detailed tracing.\n# We use DEBUG level internally but keep the default handler at INFO unless explicitly changed.\nlogging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\nlogger = logging.getLogger(__name__)\n# logger.setLevel(logging.DEBUG) # Uncomment this line to see detailed DP steps\n\ndef knapsack_dp(weights: List[int], values: List[int], capacity: int) -> Tuple[int, List[int]]:\n    \"\"\"\n    Solves the 0/1 Knapsack problem using dynamic programming (DP).\n\n    The 0/1 Knapsack problem seeks to maximize the total value of items\n    included in a knapsack without exceeding its weight capacity.\n\n    Args:\n        weights: A list of integers representing the weight of each item.\n        values: A list of integers representing the value of each item.\n        capacity: The maximum weight capacity of the knapsack.\n\n    Returns:\n        A tuple containing:\n        1. The maximum total value achievable.\n        2. A list of indices (0-based) of the items selected.\n    \"\"\"\n    n = len(weights)\n\n    if n == 0 or capacity <= 0:\n        return 0, []\n\n    # 1. Initialization: Create the DP table\n    # dp[i][w] stores the maximum value achievable using the first i items\n    # (items 0 to i-1) with a capacity of w.\n    # Size: (n + 1) rows x (capacity + 1) columns\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    logger.debug(f\"Starting DP calculation for {n} items and capacity {capacity}\")\n\n    # 2. Iteration: Fill the DP table\n    # i represents the item count (1 to n)\n    for i in range(1, n + 1):\n        # Get the weight and value of the current item (i-1 in 0-based index)\n        current_weight = weights[i - 1]\n        current_value = values[i - 1]\n\n        # w represents the current capacity (1 to capacity)\n        for w in range(1, capacity + 1):\n            \n            # Case 1: If the current item's weight exceeds the current capacity 'w',\n            # we cannot include it. The value is inherited from the previous item set.\n            if current_weight > w:\n                dp[i][w] = dp[i - 1][w]\n            \n            # Case 2: We can potentially include the item.\n            else:\n                # Option A: Exclude the item (Value from the previous item set)\n                value_excluding = dp[i - 1][w]\n                \n                # Option B: Include the item \n                # (Current value + max value achievable with the remaining capacity: w - current_weight)\n                value_including = current_value + dp[i - 1][w - current_weight]\n                \n                # Take the maximum of the two options\n                dp[i][w] = max(value_excluding, value_including)\n                \n                logger.debug(f\"i={i}, w={w}. W={current_weight}, V={current_value}. DP[{i}][{w}] = {dp[i][w]}\")\n\n    # The maximum value is stored at the bottom-right corner\n    max_value = dp[n][capacity]\n\n    # 3. Traceback: Determine which items were selected\n    selected_items: List[int] = []\n    w = capacity\n    \n    # Iterate backwards through the items (from n down to 1)\n    for i in range(n, 0, -1):\n        # If the value at dp[i][w] is different from dp[i-1][w], \n        # it means item i-1 was included to achieve this maximum value.\n        if dp[i][w] != dp[i - 1][w]:\n            # Item i-1 was selected\n            item_index = i - 1\n            selected_items.append(item_index)\n            \n            # Reduce the remaining capacity by the weight of the selected item\n            w -= weights[item_index]\n            \n            logger.debug(f\"Item {item_index} selected. Remaining capacity: {w}\")\n            \n            # Optimization: If capacity hits 0, we can stop tracing\n            if w == 0:\n                break\n\n    # The items were found in reverse order of iteration, so reverse the list for correct output\n    selected_items.reverse()\n\n    return max_value, selected_items\n\nif __name__ == \"__main__\":\n    \n    print(\"=\"*50)\n    print(\"0/1 KNAPSACK PROBLEM (DYNAMIC PROGRAMMING)\")\n    print(\"=\"*50)\n\n    # --- Example 1: Standard Test Case ---\n    \n    # Item 0: W=2, V=3\n    # Item 1: W=3, V=4\n    # Item 2: W=4, V=5\n    # Item 3: W=5, V=8\n    \n    weights1 = [2, 3, 4, 5]\n    values1 = [3, 4, 5, 8]\n    capacity1 = 5\n    \n    print(\"\\n--- Example 1: Capacity 5 ---\")\n    print(f\"Items (W, V): {list(zip(weights1, values1))}\")\n    print(f\"Capacity: {capacity1}\")\n    \n    try:\n        max_val1, selected_items1 = knapsack_dp(weights1, values1, capacity1)\n        \n        # Verification: Optimal choice is Item 3 (W=5, V=8)\n        total_weight1 = sum(weights1[i] for i in selected_items1)\n        total_value1 = sum(values1[i] for i in selected_items1)\n        \n        print(f\"\\nMaximum Value Achieved: {max_val1}\")\n        print(f\"Selected Item Indices: {selected_items1}\")\n        print(f\"Total Weight Used: {total_weight1} (Capacity Limit: {capacity1})\")\n        print(f\"Total Value Calculated: {total_value1}\")\n        \n        if max_val1 == 8 and selected_items1 == [3]:\n            print(\"Verification Status: SUCCESS\")\n        else:\n            print(\"Verification Status: FAILED (Expected Value: 8, Items: [3])\")\n            \n    except Exception as e:\n        logger.error(f\"An error occurred during Example 1 execution: {e}\")\n\n\n    # --- Example 2: Larger Test Case ---\n    \n    weights2 = [10, 20, 30]\n    values2 = [60, 100, 120]\n    capacity2 = 50\n    \n    print(\"\\n\" + \"=\"*40)\n    print(\"--- Example 2: Capacity 50 ---\")\n    print(f\"Items (W, V): {list(zip(weights2, values2))}\")\n    print(f\"Capacity: {capacity2}\")\n    \n    try:\n        max_val2, selected_items2 = knapsack_dp(weights2, values2, capacity2)\n        \n        # Verification: Optimal choice is Item 1 (W=20, V=100) + Item 2 (W=30, V=120) = W=50, V=220\n        total_weight2 = sum(weights2[i] for i in selected_items2)\n        total_value2 = sum(values2[i] for i in selected_items2)\n        \n        print(f\"\\nMaximum Value Achieved: {max_val2}\")\n        print(f\"Selected Item Indices: {selected_items2}\")\n        print(f\"Total Weight Used: {total_weight2} (Capacity Limit: {capacity2})\")\n        print(f\"Total Value Calculated: {total_value2}\")\n        \n        # Ensure the selected items are sorted for comparison\n        if max_val2 == 220 and sorted(selected_items2) == [1, 2]:\n            print(\"Verification Status: SUCCESS\")\n        else:\n            print(\"Verification Status: FAILED (Expected Value: 220, Items: [1, 2])\")\n            \n    except Exception as e:\n        logger.error(f\"An error occurred during Example 2 execution: {e}\")",
      "build_result": {
        "status": "success",
        "dependencies": [
          "logging",
          "typing",
          "None (Standard Python 3"
        ],
        "build_instructions": "Code is ready for execution",
        "errors": [],
        "suggested_fixes": []
      },
      "test_result": {
        "status": "pass",
        "test_cases": [
          {
            "name": "Basic Execution",
            "status": "pass",
            "description": "Code execution test",
            "error": null
          }
        ],
        "execution_logs": "==================================================\n0/1 KNAPSACK PROBLEM (DYNAMIC PROGRAMMING)\n==================================================\n\n--- Example 1: Capacity 5 ---\nItems (W, V): [(2, 3), (3, 4), (4, 5), (5, 8)]\nCapacity: 5\n\nMaximum Value Achieved: 8\nSelected Item Indices: [3]\nTotal Weight Used: 5 (Capacity Limit: 5)\nTotal Value Calculated: 8\nVerification Status: SUCCESS\n\n========================================\n--- Example 2: Capacity 50 ---\nItems (W, V): [(10, 60), (20, 100), (30, 120)]\nCapacity: 50\n\nMaximum Value Achieved: 220\nSelected Item Indices: [1, 2]\nTotal Weight Used: 50 (Capacity Limit: 50)\nTotal Value Calculated: 220\nVerification Status: SUCCESS\n\n",
        "performance": null,
        "issues_found": [],
        "recommendations": [
          "Code executed successfully"
        ]
      },
      "error_type": null,
      "error_message": null,
      "error_context": null
    }
  ],
  "final_code": {
    "language": "python",
    "code": "# REQUIRES: None (Standard Python 3.10+)\n\nimport logging\nfrom typing import List, Tuple\n\n# Setup basic logging. Set level to INFO for standard output, DEBUG for detailed tracing.\n# We use DEBUG level internally but keep the default handler at INFO unless explicitly changed.\nlogging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')\nlogger = logging.getLogger(__name__)\n# logger.setLevel(logging.DEBUG) # Uncomment this line to see detailed DP steps\n\ndef knapsack_dp(weights: List[int], values: List[int], capacity: int) -> Tuple[int, List[int]]:\n    \"\"\"\n    Solves the 0/1 Knapsack problem using dynamic programming (DP).\n\n    The 0/1 Knapsack problem seeks to maximize the total value of items\n    included in a knapsack without exceeding its weight capacity.\n\n    Args:\n        weights: A list of integers representing the weight of each item.\n        values: A list of integers representing the value of each item.\n        capacity: The maximum weight capacity of the knapsack.\n\n    Returns:\n        A tuple containing:\n        1. The maximum total value achievable.\n        2. A list of indices (0-based) of the items selected.\n    \"\"\"\n    n = len(weights)\n\n    if n == 0 or capacity <= 0:\n        return 0, []\n\n    # 1. Initialization: Create the DP table\n    # dp[i][w] stores the maximum value achievable using the first i items\n    # (items 0 to i-1) with a capacity of w.\n    # Size: (n + 1) rows x (capacity + 1) columns\n    dp = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n    logger.debug(f\"Starting DP calculation for {n} items and capacity {capacity}\")\n\n    # 2. Iteration: Fill the DP table\n    # i represents the item count (1 to n)\n    for i in range(1, n + 1):\n        # Get the weight and value of the current item (i-1 in 0-based index)\n        current_weight = weights[i - 1]\n        current_value = values[i - 1]\n\n        # w represents the current capacity (1 to capacity)\n        for w in range(1, capacity + 1):\n            \n            # Case 1: If the current item's weight exceeds the current capacity 'w',\n            # we cannot include it. The value is inherited from the previous item set.\n            if current_weight > w:\n                dp[i][w] = dp[i - 1][w]\n            \n            # Case 2: We can potentially include the item.\n            else:\n                # Option A: Exclude the item (Value from the previous item set)\n                value_excluding = dp[i - 1][w]\n                \n                # Option B: Include the item \n                # (Current value + max value achievable with the remaining capacity: w - current_weight)\n                value_including = current_value + dp[i - 1][w - current_weight]\n                \n                # Take the maximum of the two options\n                dp[i][w] = max(value_excluding, value_including)\n                \n                logger.debug(f\"i={i}, w={w}. W={current_weight}, V={current_value}. DP[{i}][{w}] = {dp[i][w]}\")\n\n    # The maximum value is stored at the bottom-right corner\n    max_value = dp[n][capacity]\n\n    # 3. Traceback: Determine which items were selected\n    selected_items: List[int] = []\n    w = capacity\n    \n    # Iterate backwards through the items (from n down to 1)\n    for i in range(n, 0, -1):\n        # If the value at dp[i][w] is different from dp[i-1][w], \n        # it means item i-1 was included to achieve this maximum value.\n        if dp[i][w] != dp[i - 1][w]:\n            # Item i-1 was selected\n            item_index = i - 1\n            selected_items.append(item_index)\n            \n            # Reduce the remaining capacity by the weight of the selected item\n            w -= weights[item_index]\n            \n            logger.debug(f\"Item {item_index} selected. Remaining capacity: {w}\")\n            \n            # Optimization: If capacity hits 0, we can stop tracing\n            if w == 0:\n                break\n\n    # The items were found in reverse order of iteration, so reverse the list for correct output\n    selected_items.reverse()\n\n    return max_value, selected_items\n\nif __name__ == \"__main__\":\n    \n    print(\"=\"*50)\n    print(\"0/1 KNAPSACK PROBLEM (DYNAMIC PROGRAMMING)\")\n    print(\"=\"*50)\n\n    # --- Example 1: Standard Test Case ---\n    \n    # Item 0: W=2, V=3\n    # Item 1: W=3, V=4\n    # Item 2: W=4, V=5\n    # Item 3: W=5, V=8\n    \n    weights1 = [2, 3, 4, 5]\n    values1 = [3, 4, 5, 8]\n    capacity1 = 5\n    \n    print(\"\\n--- Example 1: Capacity 5 ---\")\n    print(f\"Items (W, V): {list(zip(weights1, values1))}\")\n    print(f\"Capacity: {capacity1}\")\n    \n    try:\n        max_val1, selected_items1 = knapsack_dp(weights1, values1, capacity1)\n        \n        # Verification: Optimal choice is Item 3 (W=5, V=8)\n        total_weight1 = sum(weights1[i] for i in selected_items1)\n        total_value1 = sum(values1[i] for i in selected_items1)\n        \n        print(f\"\\nMaximum Value Achieved: {max_val1}\")\n        print(f\"Selected Item Indices: {selected_items1}\")\n        print(f\"Total Weight Used: {total_weight1} (Capacity Limit: {capacity1})\")\n        print(f\"Total Value Calculated: {total_value1}\")\n        \n        if max_val1 == 8 and selected_items1 == [3]:\n            print(\"Verification Status: SUCCESS\")\n        else:\n            print(\"Verification Status: FAILED (Expected Value: 8, Items: [3])\")\n            \n    except Exception as e:\n        logger.error(f\"An error occurred during Example 1 execution: {e}\")\n\n\n    # --- Example 2: Larger Test Case ---\n    \n    weights2 = [10, 20, 30]\n    values2 = [60, 100, 120]\n    capacity2 = 50\n    \n    print(\"\\n\" + \"=\"*40)\n    print(\"--- Example 2: Capacity 50 ---\")\n    print(f\"Items (W, V): {list(zip(weights2, values2))}\")\n    print(f\"Capacity: {capacity2}\")\n    \n    try:\n        max_val2, selected_items2 = knapsack_dp(weights2, values2, capacity2)\n        \n        # Verification: Optimal choice is Item 1 (W=20, V=100) + Item 2 (W=30, V=120) = W=50, V=220\n        total_weight2 = sum(weights2[i] for i in selected_items2)\n        total_value2 = sum(values2[i] for i in selected_items2)\n        \n        print(f\"\\nMaximum Value Achieved: {max_val2}\")\n        print(f\"Selected Item Indices: {selected_items2}\")\n        print(f\"Total Weight Used: {total_weight2} (Capacity Limit: {capacity2})\")\n        print(f\"Total Value Calculated: {total_value2}\")\n        \n        # Ensure the selected items are sorted for comparison\n        if max_val2 == 220 and sorted(selected_items2) == [1, 2]:\n            print(\"Verification Status: SUCCESS\")\n        else:\n            print(\"Verification Status: FAILED (Expected Value: 220, Items: [1, 2])\")\n            \n    except Exception as e:\n        logger.error(f\"An error occurred during Example 2 execution: {e}\")",
    "filename": "generated_script_20251205_124128.py",
    "dependencies": [
      "logging",
      "typing",
      "None (Standard Python 3"
    ]
  },
  "runtime_credentials": {},
  "missing_credentials": [],
  "total_execution_time": 145.3626425266266,
  "success": true
}