{
  "session_id": "e6e5c150",
  "requirements": "Create a FastAPI REST API for a TODO application with:\n    - SQLAlchemy database models for todos and users\n    - Pydantic schemas for request/response validation\n    - CRUD endpoints for todos (create, read, update, delete)\n    - User authentication with JWT tokens\n    - Database initialization and connection pooling\n    - Unit tests with pytest\n    - Docker support with Dockerfile\n    - GitHub Actions CI/CD workflow\n    Ensure all files have proper imports, the project structure is clean, \n    and all dependencies are correctly specified.",
  "language": "python",
  "created_at": "2025-12-05T14:07:45.635750",
  "updated_at": "2025-12-05T14:09:27.606705",
  "status": "failed",
  "current_iteration": 0,
  "max_iterations": 3,
  "iterations": [
    {
      "iteration_number": 1,
      "timestamp": "2025-12-05T14:07:45.823923",
      "code_gen_status": "success",
      "build_status": "failed",
      "test_status": "pending",
      "generated_code": null,
      "build_result": null,
      "test_result": null,
      "error_type": "VALIDATION_ERROR",
      "error_message": "Circular imports detected: config.py <-> database.py",
      "error_context": null
    },
    {
      "iteration_number": 2,
      "timestamp": "2025-12-05T14:08:23.770116",
      "code_gen_status": "success",
      "build_status": "failed",
      "test_status": "pending",
      "generated_code": null,
      "build_result": null,
      "test_result": null,
      "error_type": "VALIDATION_ERROR",
      "error_message": "Circular imports detected: app/config.py <-> app/database.py",
      "error_context": null
    },
    {
      "iteration_number": 3,
      "timestamp": "2025-12-05T14:08:50.650029",
      "code_gen_status": "success",
      "build_status": "failed",
      "test_status": "pending",
      "generated_code": null,
      "build_result": null,
      "test_result": null,
      "error_type": "VALIDATION_ERROR",
      "error_message": "Circular imports detected: config.py <-> database.py",
      "error_context": null
    }
  ],
  "final_code": null,
  "runtime_credentials": {},
  "missing_credentials": [],
  "total_execution_time": 101.97095465660095,
  "success": false,
  "project_template": "fastapi",
  "project_name": "todo_app",
  "files": [
    {
      "filename": "requirements.txt",
      "code": "fastapi\nuvicorn[standard]\nsqlalchemy[asyncio]\npydantic\npydantic-settings\npython-jose[cryptography]\npasslib[bcrypt]\naiosqlite\npytest\nhttpx\nalembic # Although not strictly required for this simple setup, good practice for migrations",
      "language": "python",
      "size": 230,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/requirements.txt"
    },
    {
      "filename": "config.py",
      "code": "from pydantic_settings import BaseSettings\n\nclass Settings(BaseSettings):\n    \"\"\"Application configuration settings.\"\"\"\n    SECRET_KEY: str = \"YOUR_SUPER_SECRET_JWT_KEY_CHANGE_ME\"\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    DATABASE_URL: str = \"sqlite+aiosqlite:///./sql_app.db\"\n\n    class Config:\n        env_file = \".env\"\n\nsettings = Settings()",
      "language": "python",
      "size": 377,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/config.py"
    },
    {
      "filename": "database.py",
      "code": "from typing import AsyncGenerator\n\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker, DeclarativeBase\n\nfrom config import settings\n\n# Define the base class for declarative models\nclass Base(DeclarativeBase):\n    pass\n\n# Create the asynchronous engine\n# echo=True is useful for debugging SQL queries\nengine = create_async_engine(\n    settings.DATABASE_URL,\n    echo=False,\n    connect_args={\"check_same_thread\": False} if \"sqlite\" in settings.DATABASE_URL else {}\n)\n\n# Create a configured \"SessionLocal\" class\nAsyncSessionLocal = sessionmaker(\n    bind=engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\nasync def init_db():\n    \"\"\"Initializes the database and creates tables if they don't exist.\"\"\"\n    async with engine.begin() as conn:\n        # Drop and recreate tables for a clean start (Development only!)\n        # await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)\n\nasync def get_db() -> AsyncGenerator[AsyncSession, None]:\n    \"\"\"Dependency function to get an asynchronous database session.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()",
      "language": "python",
      "size": 1338,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/database.py"
    },
    {
      "filename": "models.py",
      "code": "from sqlalchemy import Column, Integer, String, Boolean, ForeignKey\nfrom sqlalchemy.orm import relationship, Mapped, mapped_column\n\nfrom database import Base\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)\n    username: Mapped[str] = mapped_column(String, unique=True, index=True)\n    hashed_password: Mapped[str] = mapped_column(String)\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n\n    todos: Mapped[list[\"Todo\"]] = relationship(\"Todo\", back_populates=\"owner\")\n\nclass Todo(Base):\n    __tablename__ = \"todos\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)\n    title: Mapped[str] = mapped_column(String, index=True)\n    description: Mapped[str | None] = mapped_column(String, index=True)\n    completed: Mapped[bool] = mapped_column(Boolean, default=False)\n    \n    owner_id: Mapped[int] = mapped_column(Integer, ForeignKey(\"users.id\"))\n\n    owner: Mapped[\"User\"] = relationship(\"User\", back_populates=\"todos\")",
      "language": "python",
      "size": 1035,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/models.py"
    },
    {
      "filename": "schemas.py",
      "code": "from pydantic import BaseModel, Field\nfrom typing import Optional\n\n# --- User Schemas ---\n\nclass UserBase(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n\nclass UserCreate(UserBase):\n    password: str = Field(..., min_length=6)\n\nclass User(UserBase):\n    id: int\n    is_active: bool\n\n    class Config:\n        from_attributes = True\n\n# --- Todo Schemas ---\n\nclass TodoBase(BaseModel):\n    title: str = Field(..., min_length=1)\n    description: Optional[str] = None\n\nclass TodoCreate(TodoBase):\n    pass\n\nclass TodoUpdate(TodoBase):\n    completed: Optional[bool] = None\n\nclass Todo(TodoBase):\n    id: int\n    completed: bool\n    owner_id: int\n\n    class Config:\n        from_attributes = True\n\n# --- Auth Schemas ---\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None",
      "language": "python",
      "size": 881,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/schemas.py"
    },
    {
      "filename": "auth.py",
      "code": "from datetime import datetime, timedelta, timezone\nfrom typing import Optional\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\n\nfrom config import settings\nfrom database import get_db\nfrom models import User\nfrom schemas import TokenData\n\n# Password hashing context\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# OAuth2 scheme for token extraction\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/token\")\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verifies a plain password against a hashed password.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"Hashes a plain password.\"\"\"\n    return pwd_context.hash(password)\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Creates a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(timezone.utc) + expires_delta\n    else:\n        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n    return encoded_jwt\n\nasync def get_user_by_username(db: AsyncSession, username: str) -> Optional[User]:\n    \"\"\"Fetches a user by username.\"\"\"\n    result = await db.execute(select(User).where(User.username == username))\n    return result.scalars().first()\n\nasync def get_current_user(\n    db: AsyncSession = Depends(get_db), \n    token: str = Depends(oauth2_scheme)\n) -> User:\n    \"\"\"Dependency to retrieve the current authenticated user from the JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n\n    user = await get_user_by_username(db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Inactive user\")\n        \n    return user",
      "language": "python",
      "size": 2699,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/auth.py"
    },
    {
      "filename": "crud.py",
      "code": "from typing import List, Optional\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.future import select\nfrom sqlalchemy import update, delete\n\nfrom models import User, Todo\nfrom schemas import UserCreate, TodoCreate, TodoUpdate\nfrom auth import get_password_hash\n\n# --- User CRUD ---\n\nasync def create_user(db: AsyncSession, user: UserCreate) -> User:\n    \"\"\"Creates a new user in the database.\"\"\"\n    hashed_password = get_password_hash(user.password)\n    db_user = User(username=user.username, hashed_password=hashed_password)\n    db.add(db_user)\n    await db.commit()\n    await db.refresh(db_user)\n    return db_user\n\n# --- Todo CRUD ---\n\nasync def get_todos(db: AsyncSession, user_id: int, skip: int = 0, limit: int = 100) -> List[Todo]:\n    \"\"\"Retrieves a list of todos belonging to a specific user.\"\"\"\n    result = await db.execute(\n        select(Todo)\n        .where(Todo.owner_id == user_id)\n        .offset(skip)\n        .limit(limit)\n    )\n    return result.scalars().all()\n\nasync def create_user_todo(db: AsyncSession, todo: TodoCreate, user_id: int) -> Todo:\n    \"\"\"Creates a new todo item for a user.\"\"\"\n    db_todo = Todo(**todo.model_dump(), owner_id=user_id)\n    db.add(db_todo)\n    await db.commit()\n    await db.refresh(db_todo)\n    return db_todo\n\nasync def get_todo(db: AsyncSession, todo_id: int, user_id: int) -> Optional[Todo]:\n    \"\"\"Retrieves a specific todo item by ID and ensures ownership.\"\"\"\n    result = await db.execute(\n        select(Todo)\n        .where(Todo.id == todo_id, Todo.owner_id == user_id)\n    )\n    return result.scalars().first()\n\nasync def update_todo(db: AsyncSession, db_todo: Todo, todo_update: TodoUpdate) -> Todo:\n    \"\"\"Updates an existing todo item.\"\"\"\n    update_data = todo_update.model_dump(exclude_unset=True)\n    \n    for key, value in update_data.items():\n        setattr(db_todo, key, value)\n    \n    db.add(db_todo)\n    await db.commit()\n    await db.refresh(db_todo)\n    return db_todo\n\nasync def delete_todo(db: AsyncSession, db_todo: Todo):\n    \"\"\"Deletes a todo item.\"\"\"\n    await db.delete(db_todo)\n    await db.commit()",
      "language": "python",
      "size": 2104,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/crud.py"
    },
    {
      "filename": "routers/auth.py",
      "code": "from fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom database import get_db\nfrom schemas import UserCreate, User as UserSchema, Token\nfrom auth import get_user_by_username, verify_password, create_access_token\nfrom crud import create_user\nfrom datetime import timedelta\n\nrouter = APIRouter(prefix=\"/auth\", tags=[\"Authentication\"])\n\n@router.post(\"/register\", response_model=UserSchema, status_code=status.HTTP_201_CREATED)\nasync def register_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    \"\"\"Registers a new user.\"\"\"\n    db_user = await get_user_by_username(db, username=user.username)\n    if db_user:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Username already registered\")\n    \n    new_user = await create_user(db=db, user=user)\n    return new_user\n\n@router.post(\"/token\", response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends(), \n    db: AsyncSession = Depends(get_db)\n):\n    \"\"\"Handles user login and returns a JWT access token.\"\"\"\n    user = await get_user_by_username(db, username=form_data.username)\n    \n    if not user or not verify_password(form_data.password, user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=30)\n    access_token = create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}",
      "language": "python",
      "size": 1776,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/routers/auth.py"
    },
    {
      "filename": "routers/todos.py",
      "code": "from typing import List\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nfrom database import get_db\nfrom schemas import TodoCreate, Todo as TodoSchema, TodoUpdate\nfrom crud import create_user_todo, get_todos, get_todo, update_todo, delete_todo\nfrom auth import get_current_user\nfrom models import User\n\nrouter = APIRouter(prefix=\"/todos\", tags=[\"Todos\"])\n\n@router.post(\"/\", response_model=TodoSchema, status_code=status.HTTP_201_CREATED)\nasync def create_todo_for_current_user(\n    todo: TodoCreate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Creates a new todo item for the authenticated user.\"\"\"\n    return await create_user_todo(db=db, todo=todo, user_id=current_user.id)\n\n@router.get(\"/\", response_model=List[TodoSchema])\nasync def read_todos(\n    skip: int = 0, \n    limit: int = 100,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Retrieves all todos belonging to the authenticated user.\"\"\"\n    todos = await get_todos(db, user_id=current_user.id, skip=skip, limit=limit)\n    return todos\n\n@router.get(\"/{todo_id}\", response_model=TodoSchema)\nasync def read_todo(\n    todo_id: int,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Retrieves a specific todo item by ID.\"\"\"\n    db_todo = await get_todo(db, todo_id=todo_id, user_id=current_user.id)\n    if db_todo is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found or unauthorized\")\n    return db_todo\n\n@router.put(\"/{todo_id}\", response_model=TodoSchema)\nasync def update_todo_item(\n    todo_id: int,\n    todo_update: TodoUpdate,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Updates an existing todo item.\"\"\"\n    db_todo = await get_todo(db, todo_id=todo_id, user_id=current_user.id)\n    if db_todo is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found or unauthorized\")\n    \n    return await update_todo(db, db_todo=db_todo, todo_update=todo_update)\n\n@router.delete(\"/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo_item(\n    todo_id: int,\n    db: AsyncSession = Depends(get_db),\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"Deletes a specific todo item.\"\"\"\n    db_todo = await get_todo(db, todo_id=todo_id, user_id=current_user.id)\n    if db_todo is None:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Todo not found or unauthorized\")\n    \n    await delete_todo(db, db_todo=db_todo)\n    return",
      "language": "python",
      "size": 2698,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/routers/todos.py"
    },
    {
      "filename": "main.py",
      "code": "import logging\nfrom contextlib import asynccontextmanager\n\nfrom fastapi import FastAPI\n\nfrom database import init_db\nfrom routers import auth, todos\n\n# Configure basic logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"Handles startup and shutdown events.\"\"\"\n    logger.info(\"Application startup: Initializing database...\")\n    try:\n        await init_db()\n        logger.info(\"Database initialized successfully.\")\n    except Exception as e:\n        logger.error(f\"Failed to initialize database: {e}\")\n        # In a real application, this might be a fatal error requiring restart\n        \n    yield\n    \n    # Shutdown events (if any)\n    logger.info(\"Application shutdown.\")\n\napp = FastAPI(\n    title=\"FastAPI Todo App with JWT Auth\",\n    description=\"A simple REST API for managing todos with user authentication.\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# Include routers\napp.include_router(auth.router)\napp.include_router(todos.router)\n\n@app.get(\"/\", tags=[\"Health\"])\nasync def root():\n    return {\"message\": \"Welcome to the Todo API. Check /docs for endpoints.\"}\n\nif __name__ == \"__main__\":\n    import uvicorn\n    # Note: When running via Docker or standard deployment, uvicorn is usually run directly\n    # from the command line, not via this block. This is for local development convenience.\n    uvicorn.run(\"main:app\", host=\"0.0.0.0\", port=8000, reload=True)",
      "language": "python",
      "size": 1471,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/main.py"
    },
    {
      "filename": "test_api.py",
      "code": "# REQUIRES: pytest, httpx, sqlalchemy[asyncio], aiosqlite\n\nimport pytest\nimport httpx\nfrom sqlalchemy.ext.asyncio import create_async_engine, AsyncSession\nfrom sqlalchemy.orm import sessionmaker\n\nfrom main import app\nfrom database import Base, get_db\nfrom config import settings\nfrom models import User, Todo\nfrom auth import get_password_hash\n\n# --- Test Database Setup ---\n\n# Use an in-memory SQLite database for testing\nTEST_DATABASE_URL = \"sqlite+aiosqlite:///:memory:\"\n\n@pytest.fixture(scope=\"session\")\ndef anyio_backend():\n    \"\"\"Required for async fixtures in pytest.\"\"\"\n    return \"asyncio\"\n\n@pytest.fixture(scope=\"session\")\nasync def test_engine():\n    \"\"\"Creates the test database engine.\"\"\"\n    engine = create_async_engine(TEST_DATABASE_URL, echo=False)\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield engine\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n\n@pytest.fixture\nasync def test_db_session(test_engine):\n    \"\"\"Provides a transactional session for each test.\"\"\"\n    AsyncSessionLocal = sessionmaker(\n        bind=test_engine,\n        class_=AsyncSession,\n        expire_on_commit=False,\n    )\n    async with AsyncSessionLocal() as session:\n        # Begin a transaction\n        async with session.begin():\n            yield session\n            # Rollback the transaction after the test finishes\n            await session.rollback()\n\n@pytest.fixture\ndef override_get_db(test_db_session):\n    \"\"\"Overrides the application's get_db dependency to use the test session.\"\"\"\n    async def _override_get_db():\n        yield test_db_session\n    app.dependency_overrides[get_db] = _override_get_db\n\n@pytest.fixture\nasync def client(override_get_db):\n    \"\"\"Provides an asynchronous test client.\"\"\"\n    async with httpx.AsyncClient(app=app, base_url=\"http://test\") as client:\n        yield client\n\n# --- Helper Functions ---\n\nasync def register_and_login(client: httpx.AsyncClient, username: str, password: str):\n    \"\"\"Registers a user and returns the access token.\"\"\"\n    await client.post(\"/auth/register\", json={\"username\": username, \"password\": password})\n    \n    response = await client.post(\n        \"/auth/token\",\n        data={\"username\": username, \"password\": password},\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n    )\n    assert response.status_code == 200\n    return response.json()[\"access_token\"]\n\n# --- Tests ---\n\n@pytest.mark.asyncio\nasync def test_root(client: httpx.AsyncClient):\n    response = await client.get(\"/\")\n    assert response.status_code == 200\n    assert \"Welcome to the Todo API\" in response.json()[\"message\"]\n\n@pytest.mark.asyncio\nasync def test_register_and_login(client: httpx.AsyncClient):\n    # 1. Registration\n    response = await client.post(\n        \"/auth/register\",\n        json={\"username\": \"testuser\", \"password\": \"testpassword\"}\n    )\n    assert response.status_code == 201\n    assert response.json()[\"username\"] == \"testuser\"\n    \n    # 2. Login\n    response = await client.post(\n        \"/auth/token\",\n        data={\"username\": \"testuser\", \"password\": \"testpassword\"},\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n    )\n    assert response.status_code == 200\n    assert \"access_token\" in response.json()\n    assert response.json()[\"token_type\"] == \"bearer\"\n\n@pytest.mark.asyncio\nasync def test_todo_crud_flow(client: httpx.AsyncClient):\n    # Setup: Register and get token\n    token = await register_and_login(client, \"cruduser\", \"crudpass\")\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n\n    # 1. Create Todo\n    todo_data = {\"title\": \"Buy Milk\", \"description\": \"Need whole milk\"}\n    response = await client.post(\"/todos/\", json=todo_data, headers=headers)\n    assert response.status_code == 201\n    created_todo = response.json()\n    assert created_todo[\"title\"] == \"Buy Milk\"\n    assert created_todo[\"completed\"] is False\n    todo_id = created_todo[\"id\"]\n\n    # 2. Read Todos (List)\n    response = await client.get(\"/todos/\", headers=headers)\n    assert response.status_code == 200\n    assert len(response.json()) == 1\n    assert response.json()[0][\"id\"] == todo_id\n\n    # 3. Read Specific Todo\n    response = await client.get(f\"/todos/{todo_id}\", headers=headers)\n    assert response.status_code == 200\n    assert response.json()[\"title\"] == \"Buy Milk\"\n\n    # 4. Update Todo\n    update_data = {\"title\": \"Buy Almond Milk\", \"completed\": True}\n    response = await client.put(f\"/todos/{todo_id}\", json=update_data, headers=headers)\n    assert response.status_code == 200\n    updated_todo = response.json()\n    assert updated_todo[\"title\"] == \"Buy Almond Milk\"\n    assert updated_todo[\"completed\"] is True\n\n    # 5. Delete Todo\n    response = await client.delete(f\"/todos/{todo_id}\", headers=headers)\n    assert response.status_code == 204\n\n    # 6. Verify Deletion\n    response = await client.get(f\"/todos/{todo_id}\", headers=headers)\n    assert response.status_code == 404\n\n@pytest.mark.asyncio\nasync def test_unauthorized_access(client: httpx.AsyncClient):\n    # Attempt to access protected endpoint without token\n    response = await client.get(\"/todos/\")\n    assert response.status_code == 401\n    assert response.json()[\"detail\"] == \"Could not validate credentials\"",
      "language": "python",
      "size": 5286,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/test_api.py"
    },
    {
      "filename": "Dockerfile",
      "code": "# Use a slim Python base image\nFROM python:3.11-slim\n\n# Set environment variables\nENV PYTHONUNBUFFERED 1\nENV APP_HOME /app\nWORKDIR $APP_HOME\n\n# Install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY . $APP_HOME\n\n# Expose the port FastAPI runs on\nEXPOSE 8000\n\n# Command to run the application using Uvicorn\n# Use gunicorn with uvicorn workers for production stability\nCMD [\"uvicorn\", \"main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]",
      "language": "python",
      "size": 504,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/Dockerfile"
    },
    {
      "filename": "docker-compose.yml",
      "code": "version: '3.8'\n\nservices:\n  web:\n    build: .\n    container_name: fastapi_todo_app\n    ports:\n      - \"8000:8000\"\n    volumes:\n      # Mount the current directory for live reloading during development\n      - .:/app\n    environment:\n      # Use environment variables for configuration\n      SECRET_KEY: \"DOCKER_SECRET_KEY\"\n      DATABASE_URL: \"sqlite+aiosqlite:///./sql_app.db\"\n    # Command to enable hot reloading for development\n    command: uvicorn main:app --host 0.0.0.0 --port 8000 --reload",
      "language": "python",
      "size": 497,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/docker-compose.yml"
    },
    {
      "filename": ".github/workflows/ci.yml",
      "code": "name: Python FastAPI CI/CD\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main, develop ]\n\njobs:\n  build_and_test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout repository\n      uses: actions/checkout@v4\n\n    - name: Set up Python 3.11\n      uses: actions/setup-python@v5\n      with:\n        python-version: '3.11'\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n\n    - name: Run tests with pytest\n      # We need to ensure the test database setup works correctly\n      run: |\n        pytest test_api.py\n      env:\n        # Set environment variables for testing if needed, though test_api.py uses in-memory DB\n        SECRET_KEY: ${{ secrets.JWT_SECRET_KEY || 'TEST_SECRET' }}\n\n    - name: Build Docker image (Optional)\n      if: github.event_name == 'push' && github.ref == 'refs/heads/main'\n      uses: docker/build-push-action@v5\n      with:\n        context: .\n        push: false # Set to true if pushing to a registry like Docker Hub\n        tags: ${{ github.repository }}:latest\n        # secrets: |\n        #   JWT_SECRET_KEY=${{ secrets.JWT_SECRET_KEY }}\n        \n    - name: Linting (Optional: Add flake8 or black check here)\n      run: echo \"Linting step skipped for brevity\"\n```",
      "language": "python",
      "size": 1321,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/.github/workflows/ci.yml"
    }
  ],
  "file_tree": {
    ".gitignore": {
      "type": "file",
      "size": 93,
      "path": ".gitignore"
    },
    "Dockerfile": {
      "type": "file",
      "size": 196,
      "path": "Dockerfile"
    },
    "README.md": {
      "type": "file",
      "size": 254,
      "path": "README.md"
    },
    "requirements.txt": {
      "type": "file",
      "size": 148,
      "path": "requirements.txt"
    },
    "src": {
      "config.py": {
        "type": "file",
        "size": 15,
        "path": "config.py"
      },
      "crud.py": {
        "type": "file",
        "size": 17,
        "path": "crud.py"
      },
      "database.py": {
        "type": "file",
        "size": 17,
        "path": "database.py"
      },
      "main.py": {
        "type": "file",
        "size": 18,
        "path": "main.py"
      },
      "models.py": {
        "type": "file",
        "size": 19,
        "path": "models.py"
      },
      "schemas.py": {
        "type": "file",
        "size": 18,
        "path": "schemas.py"
      }
    },
    "tests": {
      "conftest.py": {
        "type": "file",
        "size": 17,
        "path": "conftest.py"
      },
      "test_main.py": {
        "type": "file",
        "size": 16,
        "path": "test_main.py"
      }
    }
  },
  "root_dir": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app",
  "has_dockerfile": false,
  "has_ci_config": false,
  "all_dependencies": [
    "pytest",
    "httpx",
    "pydantic_settings",
    "sqlalchemy",
    "config",
    "database",
    "pydantic",
    "fastapi",
    "jose",
    "passlib",
    "models",
    "schemas",
    "auth",
    "crud",
    "contextlib",
    "routers",
    "main",
    "sqlalchemy[asyncio]",
    "aiosqlite"
  ]
}