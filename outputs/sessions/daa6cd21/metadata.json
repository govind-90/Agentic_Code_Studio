{
  "session_id": "daa6cd21",
  "requirements": "Create a FastAPI REST API for a TODO application with:\n    - SQLAlchemy database models for todos and users\n    - Pydantic schemas for request/response validation\n    - CRUD endpoints for todos (create, read, update, delete)\n    - User authentication with JWT tokens\n    - Database initialization and connection pooling\n    - Unit tests with pytest\n    - Docker support with Dockerfile\n    - GitHub Actions CI/CD workflow\n    Ensure all files have proper imports, the project structure is clean, \n    and all dependencies are correctly specified.",
  "language": "python",
  "created_at": "2025-12-05T13:53:37.415677",
  "updated_at": "2025-12-05T13:56:05.532834",
  "status": "failed",
  "current_iteration": 0,
  "max_iterations": 3,
  "iterations": [
    {
      "iteration_number": 1,
      "timestamp": "2025-12-05T13:53:37.486210",
      "code_gen_status": "failed",
      "build_status": "pending",
      "test_status": "pending",
      "generated_code": null,
      "build_result": null,
      "test_result": null,
      "error_type": null,
      "error_message": null,
      "error_context": null
    },
    {
      "iteration_number": 2,
      "timestamp": "2025-12-05T13:54:52.143274",
      "code_gen_status": "success",
      "build_status": "failed",
      "test_status": "pending",
      "generated_code": null,
      "build_result": null,
      "test_result": null,
      "error_type": null,
      "error_message": "generated_script_20251205_135528.py:4 - invalid syntax",
      "error_context": null
    },
    {
      "iteration_number": 3,
      "timestamp": "2025-12-05T13:55:28.797355",
      "code_gen_status": "failed",
      "build_status": "pending",
      "test_status": "pending",
      "generated_code": null,
      "build_result": null,
      "test_result": null,
      "error_type": null,
      "error_message": null,
      "error_context": null
    }
  ],
  "final_code": null,
  "runtime_credentials": {},
  "missing_credentials": [],
  "total_execution_time": 148.11715602874756,
  "success": false,
  "project_template": "fastapi",
  "project_name": "todo_app",
  "files": [
    {
      "filename": "generated_script_20251205_135528.py",
      "code": "# FILE: requirements.txt\n# REQUIRES: fastapi, uvicorn, sqlalchemy, pydantic, pydantic-settings, python-jose, passlib, aiosqlite, httpx, pytest, python-multipart\n\nfastapi==0.111.0\nuvicorn[standard]==0.30.1\nsqlalchemy==2.0.30\npydantic==2.7.1\npydantic-settings==2.2.1\npython-jose[cryptography]==3.3.0\npasslib[bcrypt]==1.7.4\naiosqlite==0.20.0\nhttpx==0.27.0\npytest==8.2.0\npython-multipart==0.0.9\n\n# FILE: app/config.py\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\nfrom typing import Optional\n\nclass Settings(BaseSettings):\n    # Database configuration\n    DATABASE_URL: str = \"sqlite+aiosqlite:///./sql_app.db\"\n\n    # JWT configuration\n    SECRET_KEY: str = \"09d25e094fa841a2986c87953f93863d\" # Replace with a strong secret in production\n    ALGORITHM: str = \"HS256\"\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n\n    model_config = SettingsConfigDict(env_file=\".env\", extra=\"ignore\")\n\nsettings = Settings()\n\n# FILE: app/database.py\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase\nfrom app.config import settings\n\n# 1. Setup Engine\n# Use create_async_engine for asynchronous database access\nengine = create_async_engine(\n    settings.DATABASE_URL,\n    echo=True,\n    connect_args={\"check_same_thread\": False} if \"sqlite\" in settings.DATABASE_URL else {}\n)\n\n# 2. Setup Session Maker\n# Configure the session factory\nAsyncSessionLocal = async_sessionmaker(\n    autocommit=False,\n    autoflush=False,\n    bind=engine,\n    class_=AsyncSession,\n    expire_on_commit=False,\n)\n\n# 3. Base Class for Models\nclass Base(DeclarativeBase):\n    \"\"\"Base class which provides automated table name\n    and default primary key column.\n    \"\"\"\n    pass\n\n# Dependency to get the database session\nasync def get_db() -> AsyncSession:\n    \"\"\"Provides a database session using a context manager.\"\"\"\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n        finally:\n            await session.close()\n\n# Function to initialize the database (create tables)\nasync def init_db():\n    \"\"\"Creates all tables defined in Base metadata.\"\"\"\n    async with engine.begin() as conn:\n        # Import models here to ensure they are registered with Base metadata\n        from app import models\n        await conn.run_sync(Base.metadata.create_all)\n\n# FILE: app/models.py\nfrom sqlalchemy import Column, Integer, String, Boolean, ForeignKey\nfrom sqlalchemy.orm import relationship, Mapped, mapped_column\nfrom app.database import Base\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)\n    username: Mapped[str] = mapped_column(String, unique=True, index=True)\n    hashed_password: Mapped[str] = mapped_column(String)\n    is_active: Mapped[bool] = mapped_column(Boolean, default=True)\n\n    # Relationship to Todos\n    todos: Mapped[list[\"Todo\"]] = relationship(\"Todo\", back_populates=\"owner\")\n\nclass Todo(Base):\n    __tablename__ = \"todos\"\n\n    id: Mapped[int] = mapped_column(Integer, primary_key=True, index=True)\n    title: Mapped[str] = mapped_column(String, index=True)\n    description: Mapped[str] = mapped_column(String)\n    completed: Mapped[bool] = mapped_column(Boolean, default=False)\n    \n    # Foreign Key relationship\n    owner_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n\n    # Relationship back to User\n    owner: Mapped[\"User\"] = relationship(\"User\", back_populates=\"todos\")\n\n# FILE: app/schemas.py\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\n# --- User Schemas ---\n\nclass UserBase(BaseModel):\n    username: str = Field(..., min_length=3, max_length=50)\n\nclass UserCreate(UserBase):\n    password: str = Field(..., min_length=6)\n\nclass User(UserBase):\n    id: int\n    is_active: bool\n\n    class ConfigDict:\n        from_attributes = True\n\n# --- Todo Schemas ---\n\nclass TodoBase(BaseModel):\n    title: str = Field(..., max_length=100)\n    description: Optional[str] = None\n    completed: bool = False\n\nclass TodoCreate(TodoBase):\n    pass\n\nclass TodoUpdate(BaseModel):\n    title: Optional[str] = None\n    description: Optional[str] = None\n    completed: Optional[bool] = None\n\nclass Todo(TodoBase):\n    id: int\n    owner_id: int\n\n    class ConfigDict:\n        from_attributes = True\n\n# --- Auth Schemas ---\n\nclass Token(BaseModel):\n    access_token: str\n    token_type: str = \"bearer\"\n\nclass TokenData(BaseModel):\n    username: Optional[str] = None\n\n# FILE: app/security.py\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Annotated, Optional\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\n\nfrom app.config import settings\nfrom app.schemas import TokenData\nfrom app.models import User\nfrom app.database import get_db\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select\n\n# Password hashing context\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\n# OAuth2 scheme for token retrieval\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"auth/token\")\n\n# --- Password Utilities ---\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    \"\"\"Verifies a plain password against a hashed password.\"\"\"\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password: str) -> str:\n    \"\"\"Hashes a password.\"\"\"\n    return pwd_context.hash(password)\n\n# --- JWT Utilities ---\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    \"\"\"Creates a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(timezone.utc) + expires_delta\n    else:\n        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)\n    return encoded_jwt\n\n# --- Dependency Injection ---\n\nasync def get_user_by_username(db: AsyncSession, username: str) -> Optional[User]:\n    \"\"\"Fetches a user by username.\"\"\"\n    result = await db.execute(select(User).where(User.username == username))\n    return result.scalars().first()\n\nasync def get_current_user(\n    db: Annotated[AsyncSession, Depends(get_db)],\n    token: Annotated[str, Depends(oauth2_scheme)]\n) -> User:\n    \"\"\"Dependency to retrieve the current authenticated user from the JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    \n    try:\n        # Decode the JWT token\n        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n        token_data = TokenData(username=username)\n    except JWTError:\n        raise credentials_exception\n\n    # Fetch user from DB\n    user = await get_user_by_username(db, username=token_data.username)\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n        \n    return user\n\n# FILE: app/crud.py\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import select, delete, update\nfrom typing import List, Optional\n\nfrom app.models import User, Todo\nfrom app.schemas import UserCreate, TodoCreate, TodoUpdate\nfrom app.security import get_password_hash\n\n# --- User CRUD ---\n\nasync def create_user(db: AsyncSession, user: UserCreate) -> User:\n    \"\"\"Creates a new user with a hashed password.\"\"\"\n    hashed_password = get_password_hash(user.password)\n    db_user = User(username=user.username, hashed_password=hashed_password)\n    db.add(db_user)\n    await db.commit()\n    await db.refresh(db_user)\n    return db_user\n\nasync def get_user_by_username_crud(db: AsyncSession, username: str) -> Optional[User]:\n    \"\"\"Fetches a user by username.\"\"\"\n    result = await db.execute(select(User).where(User.username == username))\n    return result.scalars().first()\n\n# --- Todo CRUD ---\n\nasync def create_user_todo(db: AsyncSession, todo: TodoCreate, user_id: int) -> Todo:\n    \"\"\"Creates a new todo item associated with a user.\"\"\"\n    db_todo = Todo(**todo.model_dump(), owner_id=user_id)\n    db.add(db_todo)\n    await db.commit()\n    await db.refresh(db_todo)\n    return db_todo\n\nasync def get_todos(db: AsyncSession, user_id: int, skip: int = 0, limit: int = 100) -> List[Todo]:\n    \"\"\"Retrieves all todos for a specific user.\"\"\"\n    result = await db.execute(\n        select(Todo)\n        .where(Todo.owner_id == user_id)\n        .offset(skip)\n        .limit(limit)\n    )\n    return list(result.scalars().all())\n\nasync def get_todo(db: AsyncSession, todo_id: int, user_id: int) -> Optional[Todo]:\n    \"\"\"Retrieves a specific todo item by ID and owner.\"\"\"\n    result = await db.execute(\n        select(Todo)\n        .where(Todo.id == todo_id, Todo.owner_id == user_id)\n    )\n    return result.scalars().first()\n\nasync def update_todo(db: AsyncSession, db_todo: Todo, todo_update: TodoUpdate) -> Todo:\n    \"\"\"Updates an existing todo item.\"\"\"\n    update_data = todo_update.model_dump(exclude_unset=True)\n    \n    if not update_data:\n        return db_todo # Nothing to update\n\n    # Apply updates to the model instance\n    for key, value in update_data.items():\n        setattr(db_todo, key, value)\n    \n    db.add(db_todo)\n    await db.commit()\n    await db.refresh(db_todo)\n    return db_todo\n\nasync def delete_todo(db: AsyncSession, db_todo: Todo):\n    \"\"\"Deletes a todo item.\"\"\"\n    await db.delete(db_todo)\n    await db.commit()\n    return {\"message\": \"Todo deleted successfully\"}\n\n# FILE: app/routers/auth.py\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom datetime import timedelta\nfrom typing import Annotated\n\nfrom app.schemas import UserCreate, User as UserSchema, Token\nfrom app.database import get_db\nfrom app import crud\nfrom app.security import verify_password, create_access_token, get_user_by_username\nfrom app.config import settings\n\nrouter = APIRouter(prefix=\"/auth\", tags=[\"Authentication\"])\n\n@router.post(\"/signup\", response_model=UserSchema, status_code=status.HTTP_201_CREATED)\nasync def register_user(\n    user: UserCreate, \n    db: Annotated[AsyncSession, Depends(get_db)]\n):\n    \"\"\"Registers a new user.\"\"\"\n    db_user = await get_user_by_username(db, username=user.username)\n    if db_user:\n        raise HTTPException(status_code=400, detail=\"Username already registered\")\n    \n    return await crud.create_user(db=db, user=user)\n\n@router.post(\"/token\", response_model=Token)\nasync def login_for_access_token(\n    form_data: Annotated[OAuth2PasswordRequestForm, Depends()],\n    db: Annotated[AsyncSession, Depends(get_db)]\n):\n    \"\"\"Handles user login and returns a JWT access token.\"\"\"\n    user = await get_user_by_username(db, username=form_data.username)\n    \n    if not user or not verify_password(form_data.password, user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail=\"Incorrect username or password\",\n            headers={\"WWW-Authenticate\": \"Bearer\"},\n        )\n    \n    # Create token\n    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}, expires_delta=access_token_expires\n    )\n    \n    return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n\n# FILE: app/routers/todo.py\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom typing import Annotated, List\n\nfrom app.schemas import Todo as TodoSchema, TodoCreate, TodoUpdate\nfrom app.database import get_db\nfrom app import crud\nfrom app.security import get_current_user\nfrom app.models import User\n\nrouter = APIRouter(prefix=\"/todos\", tags=[\"Todos\"])\n\n@router.post(\"/\", response_model=TodoSchema, status_code=status.HTTP_201_CREATED)\nasync def create_todo_for_user(\n    todo: TodoCreate,\n    current_user: Annotated[User, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(get_db)]\n):\n    \"\"\"Creates a new todo item for the authenticated user.\"\"\"\n    return await crud.create_user_todo(db=db, todo=todo, user_id=current_user.id)\n\n@router.get(\"/\", response_model=List[TodoSchema])\nasync def read_todos(\n    current_user: Annotated[User, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(get_db)],\n    skip: int = 0,\n    limit: int = 100\n):\n    \"\"\"Retrieves all todo items belonging to the authenticated user.\"\"\"\n    todos = await crud.get_todos(db, user_id=current_user.id, skip=skip, limit=limit)\n    return todos\n\n@router.get(\"/{todo_id}\", response_model=TodoSchema)\nasync def read_todo(\n    todo_id: int,\n    current_user: Annotated[User, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(get_db)]\n):\n    \"\"\"Retrieves a specific todo item by ID.\"\"\"\n    db_todo = await crud.get_todo(db, todo_id=todo_id, user_id=current_user.id)\n    if db_todo is None:\n        raise HTTPException(status_code=404, detail=\"Todo not found\")\n    return db_todo\n\n@router.put(\"/{todo_id}\", response_model=TodoSchema)\nasync def update_todo_item(\n    todo_id: int,\n    todo_update: TodoUpdate,\n    current_user: Annotated[User, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(get_db)]\n):\n    \"\"\"Updates an existing todo item.\"\"\"\n    db_todo = await crud.get_todo(db, todo_id=todo_id, user_id=current_user.id)\n    if db_todo is None:\n        raise HTTPException(status_code=404, detail=\"Todo not found\")\n    \n    return await crud.update_todo(db, db_todo=db_todo, todo_update=todo_update)\n\n@router.delete(\"/{todo_id}\", status_code=status.HTTP_204_NO_CONTENT)\nasync def delete_todo_item(\n    todo_id: int,\n    current_user: Annotated[User, Depends(get_current_user)],\n    db: Annotated[AsyncSession, Depends(get_db)]\n):\n    \"\"\"Deletes a specific todo item.\"\"\"\n    db_todo = await crud.get_todo(db, todo_id=todo_id, user_id=current_user.id)\n    if db_todo is None:\n        raise HTTPException(status_code=404, detail=\"Todo not found\")\n    \n    await crud.delete_todo(db, db_todo=db_todo)\n    return\n\n# FILE: app/main.py\nimport uvicorn\nfrom fastapi import FastAPI, Depends\nfrom contextlib import asynccontextmanager\nimport logging\n\nfrom app.database import init_db\nfrom app.routers import auth, todo\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    \"\"\"\n    Handles startup and shutdown events.\n    Initializes the database connection and creates tables on startup.\n    \"\"\"\n    logger.info(\"Application startup: Initializing database...\")\n    try:\n        await init_db()\n        logger.info(\"Database initialized successfully.\")\n    except Exception as e:\n        logger.error(f\"Failed to initialize database: {e}\")\n        # In a real application, you might want to exit here if DB is critical\n        \n    yield\n    \n    # Shutdown logic (if needed)\n    logger.info(\"Application shutdown.\")\n\napp = FastAPI(\n    title=\"FastAPI Todo App with JWT Auth\",\n    version=\"1.0.0\",\n    lifespan=lifespan\n)\n\n# Include Routers\napp.include_router(auth.router)\napp.include_router(todo.router)\n\n@app.get(\"/\")\nasync def root():\n    return {\"message\": \"Welcome to the Todo API. Use /docs for documentation.\"}\n\nif __name__ == \"__main__\":\n    # Ensure the application runs using the correct entry point\n    uvicorn.run(\"app.main:app\", host=\"0.0.0.0\", port=8000, reload=True)\n\n# FILE: tests/test_api.py\nimport pytest\nimport httpx\nimport asyncio\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy import delete\n\n# Import necessary components from the application\nfrom app.main import app\nfrom app.database import engine, Base, get_db, AsyncSessionLocal\nfrom app.models import User, Todo\nfrom app.security import get_password_hash\n\n# Define the base URL for testing\nBASE_URL = \"http://test\"\n\n# --- Fixtures and Overrides ---\n\n# 1. Setup Test Database\n@pytest.fixture(scope=\"session\", autouse=True)\ndef event_loop():\n    \"\"\"Create an instance of the default event loop for the session.\"\"\"\n    try:\n        loop = asyncio.get_running_loop()\n    except RuntimeError:\n        loop = asyncio.new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture(scope=\"session\")\nasync def setup_db():\n    \"\"\"Initializes and tears down the database for testing.\"\"\"\n    # Ensure tables are created\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n    # Clean up tables after tests\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n\n@pytest.fixture\nasync def db_session(setup_db):\n    \"\"\"Provides a clean, transactional database session for each test.\"\"\"\n    async with AsyncSessionLocal() as session:\n        # Begin a transaction\n        async with session.begin():\n            # Override the dependency to use this session\n            def override_get_db():\n                yield session\n            app.dependency_overrides[get_db] = override_get_db\n            \n            # Clean up data before test run\n            await session.execute(delete(Todo))\n            await session.execute(delete(User))\n            await session.commit()\n            \n            yield session\n            \n            # Rollback the transaction to ensure isolation\n            await session.rollback()\n\n# 2. Setup Test Client\n@pytest.fixture\nasync def client(db_session):\n    \"\"\"Provides an asynchronous test client.\"\"\"\n    async with httpx.AsyncClient(app=app, base_url=BASE_URL) as client:\n        yield client\n\n# 3. Helper Fixtures\n@pytest.fixture\nasync def test_user_data():\n    return {\n        \"username\": \"testuser\",\n        \"password\": \"securepassword123\"\n    }\n\n@pytest.fixture\nasync def registered_user(db_session: AsyncSession, test_user_data):\n    \"\"\"Creates and returns a registered user model.\"\"\"\n    hashed_password = get_password_hash(test_user_data[\"password\"])\n    user = User(username=test_user_data[\"username\"], hashed_password=hashed_password)\n    db_session.add(user)\n    await db_session.commit()\n    await db_session.refresh(user)\n    return user\n\n@pytest.fixture\nasync def auth_token(client: httpx.AsyncClient, test_user_data, registered_user):\n    \"\"\"Logs in the registered user and returns the JWT token.\"\"\"\n    response = await client.post(\n        \"/auth/token\",\n        data={\n            \"username\": test_user_data[\"username\"],\n            \"password\": test_user_data[\"password\"],\n        },\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n    )\n    assert response.status_code == 200\n    return response.json()[\"access_token\"]\n\n# --- Tests ---\n\n@pytest.mark.asyncio\nasync def test_signup_and_login(client: httpx.AsyncClient, test_user_data):\n    # 1. Signup\n    signup_response = await client.post(\n        \"/auth/signup\",\n        json=test_user_data\n    )\n    assert signup_response.status_code == 201\n    assert signup_response.json()[\"username\"] == test_user_data[\"username\"]\n    \n    # 2. Login (Get Token)\n    login_response = await client.post(\n        \"/auth/token\",\n        data={\n            \"username\": test_user_data[\"username\"],\n            \"password\": test_user_data[\"password\"],\n        },\n        headers={\"Content-Type\": \"application/x-www-form-urlencoded\"}\n    )\n    assert login_response.status_code == 200\n    assert \"access_token\" in login_response.json()\n    assert login_response.json()[\"token_type\"] == \"bearer\"\n\n@pytest.mark.asyncio\nasync def test_create_read_update_delete_todo(client: httpx.AsyncClient, auth_token: str):\n    headers = {\"Authorization\": f\"Bearer {auth_token}\"}\n    \n    # 1. Create Todo\n    todo_data = {\"title\": \"Buy Milk\", \"description\": \"Whole milk, organic\"}\n    create_response = await client.post(\"/todos/\", json=todo_data, headers=headers)\n    assert create_response.status_code == 201\n    created_todo = create_response.json()\n    assert created_todo[\"title\"] == \"Buy Milk\"\n    assert created_todo[\"completed\"] is False\n    todo_id = created_todo[\"id\"]\n\n    # 2. Read Single Todo\n    read_single_response = await client.get(f\"/todos/{todo_id}\", headers=headers)\n    assert read_single_response.status_code == 200\n    assert read_single_response.json()[\"title\"] == \"Buy Milk\"\n\n    # 3. Read All Todos\n    read_all_response = await client.get(\"/todos/\", headers=headers)\n    assert read_all_response.status_code == 200\n    assert len(read_all_response.json()) == 1\n    assert read_all_response.json()[0][\"id\"] == todo_id\n\n    # 4. Update Todo (Mark complete)\n    update_data = {\"completed\": True, \"description\": \"Milk bought and stored.\"}\n    update_response = await client.put(f\"/todos/{todo_id}\", json=update_data, headers=headers)\n    assert update_response.status_code == 200\n    updated_todo = update_response.json()\n    assert updated_todo[\"completed\"] is True\n    assert updated_todo[\"description\"] == \"Milk bought and stored.\"\n\n    # 5. Delete Todo\n    delete_response = await client.delete(f\"/todos/{todo_id}\", headers=headers)\n    assert delete_response.status_code == 204\n\n    # 6. Verify Deletion\n    verify_delete_response = await client.get(f\"/todos/{todo_id}\", headers=headers)\n    assert verify_delete_response.status_code == 404\n\n@pytest.mark.asyncio\nasync def test_unauthorized_access(client: httpx.AsyncClient):\n    # Attempt to access protected endpoint without token\n    response = await client.get(\"/todos/\")\n    assert response.status_code == 401\n    assert response.json()[\"detail\"] == \"Not authenticated\"\n\n# FILE: Dockerfile\n# Use a lightweight Python base image\nFROM python:3.11-slim\n\n# Set environment variables\nENV PYTHONUNBUFFERED 1\nENV APP_HOME /app\nWORKDIR $APP_HOME\n\n# Install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy application code\nCOPY app $APP_HOME/app\n\n# Expose the port FastAPI runs on\nEXPOSE 8000\n\n# Command to run the application using Uvicorn\n# Use gunicorn with uvicorn workers for production deployment\nCMD [\"uvicorn\", \"app.main:app\", \"--host\", \"0.0.0.0\", \"--port\", \"8000\"]\n\n# FILE: .github/workflows/ci.yml\nname: Python CI/CD\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main, develop ]\n\njobs:\n  build_and_test:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Checkout code\n      uses: actions/checkout@v4\n\n    - name: Set up Python 3.11\n      uses: actions/setup-python@v5\n      with:\n        python-version: '3.11'\n\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n\n    - name: Run tests with pytest\n      # We use the tests/ directory structure defined in the project\n      run: |\n        pytest tests/test_api.py\n        \n    - name: Build Docker image (Optional, for verification)\n      run: |\n        docker build -t todo-fastapi-app .\n        \n    # Example of deployment step (e.g., push to Docker Hub/ECR)\n    # - name: Log in to Docker Hub\n    #   uses: docker/login-action@v3\n    #   with:\n    #     username: ${{ secrets.DOCKER_USERNAME }}\n    #     password: ${{ secrets.DOCKER_PASSWORD }}\n        \n    # - name: Push Docker image\n    #   run: |\n    #     docker tag todo-fastapi-app:latest yourusername/todo-fastapi-app:latest\n    #     docker push yourusername/todo-fastapi-app:latest\n```",
      "language": "python",
      "size": 23656,
      "filepath": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app/generated_script_20251205_135528.py"
    }
  ],
  "file_tree": {
    ".gitignore": {
      "type": "file",
      "size": 93,
      "path": ".gitignore"
    },
    "Dockerfile": {
      "type": "file",
      "size": 196,
      "path": "Dockerfile"
    },
    "README.md": {
      "type": "file",
      "size": 254,
      "path": "README.md"
    },
    "requirements.txt": {
      "type": "file",
      "size": 148,
      "path": "requirements.txt"
    },
    "src": {
      "config.py": {
        "type": "file",
        "size": 15,
        "path": "config.py"
      },
      "crud.py": {
        "type": "file",
        "size": 17,
        "path": "crud.py"
      },
      "database.py": {
        "type": "file",
        "size": 17,
        "path": "database.py"
      },
      "main.py": {
        "type": "file",
        "size": 18,
        "path": "main.py"
      },
      "models.py": {
        "type": "file",
        "size": 19,
        "path": "models.py"
      },
      "schemas.py": {
        "type": "file",
        "size": 18,
        "path": "schemas.py"
      }
    },
    "tests": {
      "conftest.py": {
        "type": "file",
        "size": 17,
        "path": "conftest.py"
      },
      "test_main.py": {
        "type": "file",
        "size": 16,
        "path": "test_main.py"
      }
    }
  },
  "root_dir": "C:\\Users\\Govind\\Projects\\agentic-code-studio\\outputs\\generated_code\\todo_app",
  "has_dockerfile": false,
  "has_ci_config": false,
  "all_dependencies": [
    "uvicorn",
    "pytest",
    "httpx",
    "asyncio",
    "pydantic_settings",
    "sqlalchemy",
    "app",
    "pydantic",
    "fastapi",
    "jose",
    "passlib",
    "contextlib",
    "pydantic-settings",
    "python-jose",
    "aiosqlite",
    "python-multipart"
  ]
}